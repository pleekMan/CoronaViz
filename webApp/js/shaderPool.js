var shaderPool = [
	{
		name: "Clean Cube",
		controlsInitial: [0, 0, 0],
		code: [
			"// CLEAN, STARTING CUBE OF VERTICES",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls; // RGB sliders",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"void main(){",
			"",
			"	vec4 finalPosition = vec4(position, 1.0);",
			"	gl_Position = projectionMatrix * modelViewMatrix * finalPosition;",
			"	vertexColor = vec4(color,1.0);",
			"	gl_PointSize = vertexSize;",
			"}"
		]
	},
	{
		name: "Twist",
		controlsInitial: [0.5, 0.2, 0],
		code: [
			"// TWIST",
			"// controls.r => Twist Amount",
			"// controls.g => Object Rotation",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls;",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"mat4 rotateY(float angle){",
			"	float c = cos(angle);",
			"	float s = sin(angle);",
			"    return mat4(",
			"        vec4(c,0.,-s,0),",
			"        vec4(0.,1.,0.,0.),",
			"        vec4(s,0.,c,0.),",
			"        vec4(0.,0.,0.,1.));",
			"}",
			"",
			"void main() {",
			"",
			"	vec4 vCentered = (vec4(position,1.0) * 2.) - vec4(1.);",
			"",
			"	float offsetY = position.y + (time * controls.g);",
			"	float angleMult = controls.r * 5.;",
			"	vec4 twisted = rotateY((offsetY * angleMult) * PI) * vCentered;",
			"",
			"	gl_Position = projectionMatrix * modelViewMatrix * twisted;",
			"	vertexColor = vec4(color,0.15);",
			"	gl_PointSize = vertexSize;",
			"",
			"} ",
		]
	},
	{
		name: "Twist Pyramid",
		controlsInitial: [0.5, 0.15, 0],
		code: [
			"// TWIST",
			"// controls.r => Twist Amount",
			"// controls.g => Rotation Speed",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls;",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"mat4 rotateY(float angle){",
			"	float c = cos(angle);",
			"	float s = sin(angle);",
			"    return mat4(",
			"        vec4(c,0.,-s,0),",
			"        vec4(0.,1.,0.,0.),",
			"        vec4(s,0.,c,0.),",
			"        vec4(0.,0.,0.,1.));",
			"}",
			"",
			"mat4 scale(vec3 factor){",
			"  return mat4(",
			"    vec4(factor.x,0.,0.,0.),",
			"    vec4(0.,factor.y,0.,0.),",
			"    vec4(0.,0.,factor.z,0.),",
			"    vec4(0.,0.,0.,1.)",
			"  );",
			"}",
			"",
			"void main() {",
			"",
			"	vec4 vCentered = (vec4(position,1.0) * 2.) - vec4(1.);",
			"",
			"	//float verticalConing = 1. - abs(vCentered.y); // Symmetric",
			"	float verticalConing = 1. - vCentered.y; // Pyramid",
			"",
			"	vCentered = scale(vec3(verticalConing, 1., verticalConing)) * vCentered;",
			"",
			"	float angleOffsetY = position.y + (time * controls.g);",
			"	float angleMult = controls.r * 5.;",
			"	vec4 twisted = rotateY((angleOffsetY * angleMult) * PI) * vCentered;",
			"",
			"	gl_Position = projectionMatrix * modelViewMatrix * twisted;",
			"	vertexColor = vec4(color,0.3);",
			"	gl_PointSize = vertexSize;",
			"",
			"} "
		]
	},
	{
		name: "Cheese Noise",
		controlsInitial: [0.25, 0.75, 0.16],
		code: [
			"// CHEESE NOISE",
			"// controls.r => Speed",
			"// controls.g => Hole Depth (Carve Strength)",
			"// controls.b => Hole Size",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls;",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"// Simplex noise from: https://github.com/hughsk/glsl-noise",
			"vec3 mod289(vec3 x) {",
			"  return x - floor(x * (1.0 / 289.0)) * 289.0;",
			"}",
			"",
			"vec4 mod289(vec4 x) {",
			"  return x - floor(x * (1.0 / 289.0)) * 289.0;",
			"}",
			"",
			"vec4 permute(vec4 x) {",
			"     return mod289(((x*34.0)+1.0)*x);",
			"}",
			"",
			"vec4 taylorInvSqrt(vec4 r)",
			"{",
			"  return 1.79284291400159 - 0.85373472095314 * r;",
			"}",
			"",
			"float snoise(vec3 v)",
			"{",
			"  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;",
			"  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);",
			"",
			"	// First corner",
			"  vec3 i  = floor(v + dot(v, C.yyy) );",
			"  vec3 x0 =   v - i + dot(i, C.xxx) ;",
			"",
			"	// Other corners",
			"  vec3 g = step(x0.yzx, x0.xyz);",
			"  vec3 l = 1.0 - g;",
			"  vec3 i1 = min( g.xyz, l.zxy );",
			"  vec3 i2 = max( g.xyz, l.zxy );",
			"",
			"  //   x0 = x0 - 0.0 + 0.0 * C.xxx;",
			"  //   x1 = x0 - i1  + 1.0 * C.xxx;",
			"  //   x2 = x0 - i2  + 2.0 * C.xxx;",
			"  //   x3 = x0 - 1.0 + 3.0 * C.xxx;",
			"  vec3 x1 = x0 - i1 + C.xxx;",
			"  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y",
			"  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y",
			"",
			"	// Permutations",
			"  i = mod289(i);",
			"  vec4 p = permute( permute( permute(",
			"             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))",
			"           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))",
			"           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));",
			"",
			"	// Gradients: 7x7 points over a square, mapped onto an octahedron.",
			"	// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)",
			"  float n_ = 0.142857142857; // 1.0/7.0",
			"  vec3  ns = n_ * D.wyz - D.xzx;",
			"",
			"  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)",
			"",
			"  vec4 x_ = floor(j * ns.z);",
			"  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)",
			"",
			"  vec4 x = x_ *ns.x + ns.yyyy;",
			"  vec4 y = y_ *ns.x + ns.yyyy;",
			"  vec4 h = 1.0 - abs(x) - abs(y);",
			"",
			"  vec4 b0 = vec4( x.xy, y.xy );",
			"  vec4 b1 = vec4( x.zw, y.zw );",
			"",
			"  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;",
			"  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;",
			"  vec4 s0 = floor(b0)*2.0 + 1.0;",
			"  vec4 s1 = floor(b1)*2.0 + 1.0;",
			"  vec4 sh = -step(h, vec4(0.0));",
			"",
			"  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;",
			"  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;",
			"",
			"  vec3 p0 = vec3(a0.xy,h.x);",
			"  vec3 p1 = vec3(a0.zw,h.y);",
			"  vec3 p2 = vec3(a1.xy,h.z);",
			"  vec3 p3 = vec3(a1.zw,h.w);",
			"",
			"	//Normalise gradients",
			"  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));",
			"  p0 *= norm.x;",
			"  p1 *= norm.y;",
			"  p2 *= norm.z;",
			"  p3 *= norm.w;",
			"",
			"	// Mix final noise value",
			"  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);",
			"  m = m * m;",
			"  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),",
			"                                dot(p2,x2), dot(p3,x3) ) );",
			"  }",
			"",
			"",
			"mat4 scale(vec3 factor){",
			"  return mat4(",
			"    vec4(factor.x,0.,0.,0.),",
			"    vec4(0.,factor.y,0.,0.),",
			"    vec4(0.,0.,factor.z,0.),",
			"    vec4(0.,0.,0.,1.)",
			"  );",
			"}",
			"",
			"void main() {",
			"",
			"    vec4 vCentered = vec4(vec3(position),1.) * 2. - vec4(1.);",
			"    vCentered.y = vCentered.y * 0.5 + 0.5;",
			"    //vec2 normMouse = mouse / resolution;",
			"    //vec2 mouseCentered = (normMouse * 2.) - vec2(1.);",
			"    //mouseCentered.y = 1. - mouseCentered.y;",
			"",
			"    float noiseStrength = snoise((vCentered.xyz * (controls.b * 10.)) + (time * controls.r));",
			"    vec4 pushVector  = (vCentered - vec4(0)) * (controls.g * 10.); // CHEESE",
			"",
			"    vec4 pushed = vCentered + (pushVector * noiseStrength);",
			"",
			"    //vec4 scaled = scale(vec3(100.)) * pushed;",
			"",
			"",
			"    vec4 finalPos = projectionMatrix  * modelViewMatrix * pushed;",
			"    gl_Position = finalPos;	",
			"    vertexColor = vec4(color,1.0);",
			"	  gl_PointSize = vertexSize;",
			"}",
		]

	},
	{
		name: "Moebius",
		controlsInitial: [0, 0, 0.5],
		code: [
			"// INFINITY MOEBIUS",
			"// controls.g => Travel along surface",
			"// controls.b => Scale",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls;",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"mat4 scale(vec3 factor){",
			"  return mat4(",
			"    vec4(factor.x,0.,0.,0.),",
			"    vec4(0.,factor.y,0.,0.),",
			"    vec4(0.,0.,factor.z,0.),",
			"    vec4(0.,0.,0.,1.)",
			"  );",
			"}",
			"",
			"mat4 rotateY(float angle){",
			"	float c = cos(angle);",
			"	float s = sin(angle);",
			"    return mat4(",
			"        vec4(c,0.,-s,0),",
			"        vec4(0.,1.,0.,0.),",
			"        vec4(s,0.,c,0.),",
			"        vec4(0.,0.,0.,1.));",
			"}",
			"",
			"void main(){",
			"",
			"	vec4 movingUV = vec4(fract(position.x ), fract(position.y + controls.g), 1., 1.);",
			"	vec3 toSphereRange = vec3(movingUV.x * (TWO_PI), movingUV.y * (TWO_PI), movingUV.z * TWO_PI);",
			"",
			"	vec4 spherized = vec4(1);",
			"	spherized.x =  cos(toSphereRange.x) * sin(toSphereRange.y);",
			"	spherized.y = sin(toSphereRange.y) * cos(toSphereRange.y);",
			"	spherized.z = cos(toSphereRange.x);",
			"",
			"	spherized = rotateY(time * 0.1) * spherized;",
			"	vec4 scaled = scale(vec3(controls.b * 2.)) * spherized;",
			"",
			"	gl_Position = projectionMatrix * modelViewMatrix * scaled;",
			"	vertexColor = vec4(color,1.0);",
			"	gl_PointSize = vertexSize;",
			"}",
		]
	},
	{
		name: "Grid",
		controlsInitial: [0.5, 0.5, 0],
		code: [
			"// GRID",
			"// controls.r => Module cutOff",
			"// controls.g => Module Count",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls; // RGB sliders",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"void main(){",
			"  	",
			"	vec3 grid = step(controls.r,fract(position * (controls.g * 10.)));",
			"	float unite = grid.x * grid.y * grid.z; // For setting the alpha component vertexColor",
			"",
			"	vec4 vCentered = vec4(vec3(position),1.) * 2. - vec4(1.);",
			"",
			"	vec4 finalPosition = vec4(position,1.);",
			"	gl_Position = projectionMatrix * modelViewMatrix * vCentered;",
			"	vertexColor = vec4(color,unite);",
			"	gl_PointSize = vertexSize;",
			"}",
		]

	},
	{
		name: "Propeller",
		controlsInitial: [0.5, 0.24, 0.4],
		code: [
			"// PROPELLER",
			"// controls.r => Number of blades",
			"// controls.g => Rotation speed",
			"// controls.b => Blade thickness",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls; // RGB sliders",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"mat4 rotateZ(float angle){",
			"	float c = cos(angle);",
			"	float s = sin(angle);",
			"    return mat4(",
			"        vec4(c,-s,0.,0),",
			"        vec4(s,c,0.,0.),",
			"        vec4(0.,0.,1.,0.),",
			"        vec4(0.,0.,0.,1.));",
			"}",
			"",
			"void main(){",
			"	",
			"	vec3 vCentered = position * 2. - 1.;",
			"",
			"	// ANGLE FOR VERTEX ALPHA",
			"	float angle = atan(vCentered.y / vCentered.x);",
			"	angle *= 0.5;",
			"	angle = fract(angle * (10. * controls.r));",
			"	float alpha = angle;",
			"	alpha *= 1.1 - length(vCentered.xy); // FADE OUT THE BLADES A LITTLE BIT",
			"",
			"	// CHOP FROM FRONT AND BACK",
			"	float bladeThickness = controls.b * 0.3;",
			"	float limitCage = (1.- (step(bladeThickness,vCentered.z))) * step(-bladeThickness,vCentered.z) ;  ",
			"	alpha *= limitCage;",
			"",
			"	// CENTER-BALL",
			"	float ballCut = 1. - step(0.25, length(vCentered.xyz));",
			"	alpha += ballCut;",
			"",
			"	// CUT AROUND CIRCULARLY",
			"	float cutCircle = 1. - step(1., length(vCentered.xy));",
			"	alpha *= cutCircle;",
			"",
			"	// ROTATION: APPLY ROTATION MATRIX TO VERTEX position  ",
			"	vec4 finalPosition = rotateZ(-time * controls.g * 5.) * vec4(vCentered, 1.);",
			"",
			"	gl_Position = projectionMatrix * modelViewMatrix * finalPosition;",
			"	vertexColor = vec4(color,alpha);",
			"	gl_PointSize = vertexSize;",
			"}",
		]

	},
	{
		name: "Pulsing Bird-Cage",
		controlsInitial: [0.64, -0.46, 0.48],
		code: [
			"// PULSING BIRD-CAGE",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls; // RGB sliders",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"float arcFunction(float yPos){",
			"		return abs(sin((yPos * PI)+ time) + 0.3",
			"  			* cos(time * 2. * yPos));",
			"}",
			"",
			"void main(){",
			"",
			"  vec3 vCentered = position * 2. - 1.;",
			"	vCentered.y = (vCentered.y + 1.) * 0.5; // SET HEIGHT TO 0 -> 1 BACK AGAIN",
			"",
			"	// ANGLE FOR VERTEX ALPHA",
			"	float angle = atan(vCentered.z / vCentered.x);",
			"	angle = fract(angle * (5. * controls.r));",
			"  angle = step(0.8,angle);",
			"	",
			"  // ARC",
			"  	",
			"	float arc = arcFunction(vCentered.y) * controls.b; // controls.b = cage size",
			"  	",
			"	float lineWeight = 0.3;",
			"	float arcIn = 1. - step(arc + lineWeight, length(vCentered.xz) * (1.0 - controls.g)); // DISTANCE TO ARC FILL INSIDE",
			"	float arcOut = step(arc, length(vCentered.xz));  // DISTANCE TO ARC FILL INSIDE",
			"",
			"	angle *= arcIn * arcOut; // INTERSECTION",
			"",
			"	// COLOR",
			"	vec3 newColor = vec3(sin(arc * 0.8),cos(arc + time) * 0.3,angle * 0.4);",
			"",
			"	vec4 finalPosition = vec4(vCentered * 1.5, 1.0);",
			"	gl_Position = projectionMatrix * modelViewMatrix * finalPosition;",
			"	vertexColor = vec4(newColor,angle);",
			"	gl_PointSize = vertexSize * 1.5;",
			"}",
		]
	},
	{
		name: "Wave",
		controlsInitial: [0.5, 0, 0],
		code: [
			"// Wave :: Vertical Sine wave",
			"// controls.r => Wave Speed",
			"// controls.g => Move Vertically",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"",
			"uniform vec3 controls;",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"void main() {",
			"",
			"	float wavyX = position.x * sin(position.y * TWO_PI + (time * controls.r ) ); // DRAG THE RED SLIDER",
			"	float offsetY = position.y + controls.g; // DRAG THE GREEN SLIDER",
			"	vec4 finalPos = vec4(wavyX, offsetY, position.z, 1.0);",
			"",
			"	gl_Position = projectionMatrix * modelViewMatrix * finalPos;",
			"	vertexColor = vec4(color,1.0);",
			"	gl_PointSize = vertexSize;",
			"}"
		]

	},
	{
		name: "Wave (Camera oriented)",
		controlsInitial: [0.5, 0, 0],
		code: [
			"// WAVE - CAMERA ORIENTED",
			"// MODIFYING THE VERTEX POSITION AFTER APPLYING THE MODEL-VIEW MATRIX",
			"",
			"const float PI = 3.14159265358;",
			"const float TWO_PI = 6.28318530718;",
			"const float HALF_PI = 1.57079632679;",
			"",
			"uniform vec3 controls; // RGB sliders",
			"uniform float time; // IN SECONDS",
			"varying vec4 vertexColor;",
			"attribute float vertexSize;",
			"",
			"void main(){",
			"",
			"	vec4 camPos = modelViewMatrix * vec4(position, 1.0);",
			"	camPos.x += sin(camPos.y * 10.) * 0.25;",
			"",
			"	gl_Position = projectionMatrix * camPos;",
			"	vertexColor = vec4(color,1.0);",
			"	gl_PointSize = vertexSize;",
			"}",
		]

	}
]




